<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cosmere Knowledge Graph — Words of Brandon</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/animations.css">
<link rel="stylesheet" href="css/graph.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/components.css">
</head>
<body>

<!-- ── Loading Screen ────────────────────────────────────────── -->
<div id="loading">
  <svg id="glyph" viewBox="-100 -100 200 200" width="150" height="150">
    <circle class="glyph-ring" cx="0" cy="0" r="40"/>
    <circle class="glyph-inner" cx="0" cy="0" r="18"/>
    <path class="glyph-ray" d="M46,0 L70,0" style="animation-delay:1.0s"/>
    <path class="glyph-ray" d="M32.5,32.5 L49.5,49.5" style="animation-delay:1.05s"/>
    <path class="glyph-ray" d="M0,46 L0,70" style="animation-delay:1.1s"/>
    <path class="glyph-ray" d="M-32.5,32.5 L-49.5,49.5" style="animation-delay:1.15s"/>
    <path class="glyph-ray" d="M-46,0 L-70,0" style="animation-delay:1.2s"/>
    <path class="glyph-ray" d="M-32.5,-32.5 L-49.5,-49.5" style="animation-delay:1.25s"/>
    <path class="glyph-ray" d="M0,-46 L0,-70" style="animation-delay:1.3s"/>
    <path class="glyph-ray" d="M32.5,-32.5 L49.5,-49.5" style="animation-delay:1.35s"/>
    <circle class="glyph-dot" cx="76" cy="0" r="3" style="animation-delay:1.45s"/>
    <circle class="glyph-dot" cx="53.7" cy="53.7" r="3" style="animation-delay:1.5s"/>
    <circle class="glyph-dot" cx="0" cy="76" r="3" style="animation-delay:1.55s"/>
    <circle class="glyph-dot" cx="-53.7" cy="53.7" r="3" style="animation-delay:1.6s"/>
    <circle class="glyph-dot" cx="-76" cy="0" r="3" style="animation-delay:1.65s"/>
    <circle class="glyph-dot" cx="-53.7" cy="-53.7" r="3" style="animation-delay:1.7s"/>
    <circle class="glyph-dot" cx="0" cy="-76" r="3" style="animation-delay:1.75s"/>
    <circle class="glyph-dot" cx="53.7" cy="-53.7" r="3" style="animation-delay:1.8s"/>
  </svg>
  <div id="loading-text">Connecting the Cosmere...</div>
</div>

<!-- ── Stormlight Particles ──────────────────────────────────── -->
<canvas id="particles"></canvas>

<!-- ── Graph ─────────────────────────────────────────────────── -->
<div id="graph-container">
  <svg id="graph-svg"></svg>
</div>

<!-- ── Header ────────────────────────────────────────────────── -->
<div id="header">
  <h1 id="title">Cosmere Knowledge Graph</h1>
  <div id="subtitle">Words of Brandon</div>
  <div id="header-line"></div>
  <div id="search-box">
    <input type="text" id="search-input" placeholder='Search entities... ( / )'>
    <button id="search-clear">&times;</button>
    <div id="search-suggestions"></div>
  </div>
  <button id="guide-btn">Worldhopper's Guide</button>
</div>

<!-- ── Filters ───────────────────────────────────────────────── -->
<div id="filters"></div>

<!-- ── Embedding Controls ────────────────────────────────────── -->
<div id="embedding-controls-bar">
  <span class="bar-label">Embeddings</span>
  <button id="tuning-toggle-btn">Tune</button>
  <button id="apply-embeddings-btn">Apply</button>
  <span id="embedding-stats">Ready to compute</span>
  <div id="edge-layer-toggle">
    <span class="edge-layer-option">
      <input type="radio" name="edge-layer" id="edge-layer-explicit" value="explicit">
      <label for="edge-layer-explicit">Explicit</label>
    </span>
    <span class="edge-layer-option">
      <input type="radio" name="edge-layer" id="edge-layer-both" value="both" checked>
      <label for="edge-layer-both">Both</label>
    </span>
    <span class="edge-layer-option">
      <input type="radio" name="edge-layer" id="edge-layer-implicit" value="implicit">
      <label for="edge-layer-implicit">Implicit</label>
    </span>
  </div>
  <button id="review-toggle-btn">Review</button>
</div>

<div id="tuning-panel">
  <h3>Embedding Tuning</h3>

  <div class="tuning-row">
    <label>
      <span>Calibration Percentile</span>
      <span class="slider-value" id="value-calibration-percentile">25</span>
    </label>
    <input type="range" id="slider-calibration-percentile"
           aria-label="Calibration Percentile"
           min="10" max="50" step="5" value="25">
  </div>

  <div class="tuning-row">
    <label>
      <span>Min Specificity</span>
      <span class="slider-value" id="value-min-specificity">2.0</span>
    </label>
    <input type="range" id="slider-min-specificity"
           aria-label="Min Specificity"
           min="0" max="5" step="0.1" value="2">
  </div>

  <div class="tuning-row">
    <label>
      <span>Confidence Margin</span>
      <span class="slider-value" id="value-confidence-margin">0.05</span>
    </label>
    <input type="range" id="slider-confidence-margin"
           aria-label="Confidence Margin"
           min="0" max="0.15" step="0.01" value="0.05">
  </div>

  <div class="tuning-row">
    <label>
      <span>Min Edge Weight</span>
      <span class="slider-value" id="value-min-edge-weight">2</span>
    </label>
    <input type="range" id="slider-min-edge-weight"
           aria-label="Min Edge Weight"
           min="2" max="10" step="1" value="2">
  </div>

  <div class="tuning-checkbox-row">
    <input type="checkbox" id="checkbox-must-bridge" checked>
    <label for="checkbox-must-bridge">Must-Bridge (remove orphan tags)</label>
  </div>
</div>

<!-- ── Side Panel ────────────────────────────────────────────── -->
<div id="panel">
  <button id="panel-close">&times;</button>
  <div id="panel-content"></div>
</div>

<!-- ── Review Panel ─────────────────────────────────────────── -->
<div id="review-panel">
  <button id="review-close-btn" aria-label="Close review panel">&times;</button>
  <h3>Review Implicit Tags</h3>
  <div class="review-subtitle" id="review-subtitle">No implicit tags computed yet</div>
  <div id="review-actions">
    <button id="save-reviews-btn">Save Reviews</button>
    <button id="load-reviews-btn">Load Reviews</button>
    <select id="review-sort-select">
      <option value="score-desc">Score (high to low)</option>
      <option value="score-asc">Score (low to high)</option>
      <option value="entity-asc">Entity (A-Z)</option>
      <option value="status">Status</option>
    </select>
    <label id="review-filter-label"><input type="checkbox" id="review-filter-unreviewed"> Unreviewed only</label>
  </div>
  <div class="review-table" id="review-table"></div>
</div>

<!-- ── Guide Modal ─────────────────────────────────────────── -->
<div id="guide-overlay">
  <div id="guide-modal">
    <button id="guide-close">&times;</button>

    <div class="guide-title">Welcome, Worldhopper</div>
    <div class="guide-epigraph">"The most important step a man can take. It's not the first one, is it?<br>It's the next one. Always the next one."</div>

    <div class="guide-section">
      <p>You're looking at a map of every connection Brandon Sanderson has drawn between the people, places, and powers of the Cosmere -- built from <strong style="color:var(--stormlight)">16,282</strong> of his own answers to fan questions.</p>
      <p>Each gemstone is an entity he's discussed. Each thread between them is a connection he's made -- two topics mentioned in the same Q&amp;A. The bigger the gemstone, the more he's talked about it. Kaladin blazes large. Geranid, less so.</p>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section">
      <h3><span class="guide-gem" style="background:var(--gem-sapphire-glow)"></span>The Gemstones</h3>
      <p>Five gemstone types, five kinds of Cosmere knowledge:</p>
      <div class="gem-legend">
        <div class="gem-legend-row">
          <span class="gem-legend-dot" style="background:var(--gem-sapphire-glow)"></span>
          <span class="gem-legend-name" style="color:var(--gem-sapphire-glow)">Sapphire</span>
          <span><strong>Characters</strong> -- the people, spren, kandra, and Cognitive Shadows. <span class="gem-legend-examples">Kaladin, Hoid, Vin, Kelsier, Shallan, Nightblood...</span></span>
        </div>
        <div class="gem-legend-row">
          <span class="gem-legend-dot" style="background:var(--gem-emerald-glow)"></span>
          <span class="gem-legend-name" style="color:var(--gem-emerald-glow)">Emerald</span>
          <span><strong>Worlds</strong> -- the planets and realms. <span class="gem-legend-examples">Roshar, Scadrial, Sel, Nalthis, the Cognitive Realm...</span></span>
        </div>
        <div class="gem-legend-row">
          <span class="gem-legend-dot" style="background:var(--gem-amethyst-glow)"></span>
          <span class="gem-legend-name" style="color:var(--gem-amethyst-glow)">Amethyst</span>
          <span><strong>Magic Systems</strong> -- the Invested Arts. <span class="gem-legend-examples">Allomancy, Surgebinding, Awakening, Hemalurgy, Feruchemy...</span></span>
        </div>
        <div class="gem-legend-row">
          <span class="gem-legend-dot" style="background:var(--gem-heliodor-glow)"></span>
          <span class="gem-legend-name" style="color:var(--gem-heliodor-glow)">Heliodor</span>
          <span><strong>Shards</strong> -- the sixteen fragments of Adonalsium. <span class="gem-legend-examples">Honor, Odium, Preservation, Ruin, Endowment, Autonomy...</span></span>
        </div>
        <div class="gem-legend-row">
          <span class="gem-legend-dot" style="background:var(--gem-ruby-glow)"></span>
          <span class="gem-legend-name" style="color:var(--gem-ruby-glow)">Ruby</span>
          <span><strong>Concepts</strong> -- the underlying mechanics and lore. <span class="gem-legend-examples">Investiture, Knights Radiant, Desolations, Connection, Identity...</span></span>
        </div>
      </div>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section">
      <h3><span class="guide-gem" style="background:var(--gem-emerald-glow)"></span>Exploring the Map</h3>
      <ul>
        <li><strong style="color:var(--stormlight)">Tap a gemstone</strong> to focus on it. Everything unrelated fades, and a panel opens showing its connections and how strong each one is.</li>
        <li><strong style="color:var(--stormlight)">Tap a connection</strong> in the panel to read the actual Q&amp;A entries -- Brandon's exact words on how Nightblood relates to Vasher, or why the Cognitive Realm works differently on Sel.</li>
        <li><strong style="color:var(--stormlight)">Search</strong> (or press <span class="guide-kbd">/</span>) to jump to any entity. Start typing "Hoid" and watch the suggestions appear.</li>
        <li><strong style="color:var(--stormlight)">Filter</strong> by type to isolate what interests you. Turn off Characters to see only magic-system-to-world connections. Turn off everything except Shards to see how Adonalsium's fragments relate to each other.</li>
      </ul>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section">
      <h3><span class="guide-gem" style="background:var(--gem-heliodor-glow)"></span>Discovering Hidden Connections</h3>
      <p>The bar at the bottom labeled <strong style="color:var(--gem-heliodor-glow)">Embeddings</strong> is where things get interesting.</p>
      <p>The base graph only shows <strong>explicit</strong> connections -- entity pairs that were literally tagged together in Arcanum's database. But Brandon often discusses an entity without it being formally tagged. He might answer a question tagged only "Allomancy" but spend half the answer talking about Preservation.</p>
      <p>The embedding system reads the <em>text</em> of every Q&amp;A entry and uses AI similarity matching to find these hidden connections. Press <strong style="color:var(--gem-heliodor-glow)">Apply</strong> and new <strong>dashed amber lines</strong> appear -- connections the tags missed, but Brandon's words reveal.</p>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section">
      <h3><span class="guide-gem" style="background:var(--gem-amethyst-glow)"></span>Fine-Tuning the Discovery</h3>
      <p>Press <strong style="color:var(--gem-heliodor-glow)">Tune</strong> to control how aggressively the system discovers connections:</p>
      <table class="guide-tuning-table">
        <thead>
          <tr><th>Control</th><th>What It Does</th></tr>
        </thead>
        <tbody>
          <tr>
            <td>Calibration Percentile</td>
            <td>
              How confident do we need to be? Lower = cast a wider net. Higher = only the most obvious discoveries.
              <span class="guide-tuning-example">At 10, a Q&amp;A about "Investiture mechanics" might get tagged with Preservation. At 50, only entries that practically name-drop Preservation would qualify.</span>
            </td>
          </tr>
          <tr>
            <td>Min Specificity</td>
            <td>
              Filters out hub entities that match everything loosely. Higher values only use focused entities.
              <span class="guide-tuning-example">"Allomancy" appears in hundreds of entries and matches everything -- it gets filtered out. "Lerasium" is specific enough to produce meaningful connections.</span>
            </td>
          </tr>
          <tr>
            <td>Confidence Margin</td>
            <td>
              When multiple entities could match an entry, how close does a runner-up need to be to the top scorer?
              <span class="guide-tuning-example">An entry scores 0.82 for Preservation and 0.79 for Ruin. With margin 0.05, both pass (gap is only 0.03). With margin 0.01, only Preservation is kept.</span>
            </td>
          </tr>
          <tr>
            <td>Min Edge Weight</td>
            <td>
              How many shared entries do two entities need before we draw a connection? Higher = fewer, stronger lines.
              <span class="guide-tuning-example">At 2, a single coincidence isn't enough -- entities must co-occur at least twice.</span>
            </td>
          </tr>
          <tr>
            <td>Must-Bridge</td>
            <td>
              Only tag entries that already mention something else. Prevents orphan discoveries floating in the void.
              <span class="guide-tuning-example">An entry with no existing tags won't receive an implicit tag, since there's nothing for it to bridge to.</span>
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section">
      <h3><span class="guide-gem" style="background:var(--gem-ruby-glow)"></span>Reviewing What Was Found</h3>
      <p>After pressing Apply, click <strong style="color:var(--gem-heliodor-glow)">Review</strong> to see every implicit tag the system discovered. You can sort by confidence score, confirm tags that look right, reject false positives, and save your reviews to a file.</p>
      <p>Use the <strong style="color:var(--stormlight)">Explicit / Both / Implicit</strong> radio toggle to switch which edge layer is visible -- see only the original graph, only the discoveries, or both overlaid.</p>
    </div>

    <div class="guide-divider"></div>

    <div class="guide-section" style="text-align:center;">
      <p style="color:rgba(200,223,255,0.3); font-family:var(--font-display); font-size:13px; font-style:italic;">Data from 16,282 Words of Brandon entries on Arcanum &middot; wob.coppermind.net</p>
    </div>
  </div>
</div>

<!-- ── Tooltip ───────────────────────────────────────────────── -->
<div id="tooltip"></div>

<!-- ── Info ───────────────────────────────────────────────────── -->
<div id="info">
  <span class="info-title">Cosmere Knowledge Graph</span> &middot;
  <span id="node-count"></span> entities &middot;
  <span id="edge-count"></span> connections &middot;
  Data from <a href="https://wob.coppermind.net/" target="_blank">Arcanum</a>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="js/tagging-engine.js"></script>
<script>
// ── Gemstone Constants ──────────────────────────────────────────────────────

const GEM_COLORS = {
  character: '#2E5BA8',
  world:     '#2D8B57',
  magic:     '#7B4BAA',
  shard:     '#C49A2A',
  concept:   '#B03A3A',
};

const GEM_GLOW = {
  character: '#4A8BDF',
  world:     '#3FBF7F',
  magic:     '#A66ED8',
  shard:     '#E8C44A',
  concept:   '#D45A5A',
};

const GEM_HIGHLIGHT = {
  character: '#6AADFF',
  world:     '#5FE8A0',
  magic:     '#C490F0',
  shard:     '#F0D870',
  concept:   '#E87070',
};

const GEM_NAMES = {
  character: 'Sapphire',
  world:     'Emerald',
  magic:     'Amethyst',
  shard:     'Heliodor',
  concept:   'Ruby',
};

const TYPE_LABELS = {
  character: 'Characters',
  world:     'Worlds',
  magic:     'Magic Systems',
  shard:     'Shards',
  concept:   'Concepts',
};

// ── Mobile Backdrops ────────────────────────────────────────────────────────

var _panelBackdrop = null;
var _reviewBackdrop = null;

function isMobile() {
  return window.matchMedia('(max-width: 768px)').matches;
}

function createBackdrop(closeFn) {
  var backdrop = document.createElement('div');
  backdrop.className = 'panel-backdrop';
  backdrop.addEventListener('click', closeFn);
  document.body.appendChild(backdrop);
  return backdrop;
}

function showBackdrop(backdrop) {
  if (backdrop && isMobile()) {
    backdrop.classList.add('visible');
  }
}

function hideBackdrop(backdrop) {
  if (backdrop) {
    backdrop.classList.remove('visible');
  }
}

function setupBackdrops() {
  _panelBackdrop = createBackdrop(function() { unfocus(); });
  _reviewBackdrop = createBackdrop(function() {
    document.getElementById('review-panel').classList.remove('open');
    hideBackdrop(_reviewBackdrop);
  });
  // z-index: side panel backdrop behind panel (z20), review behind review (z25)
  _panelBackdrop.style.zIndex = '19';
  _reviewBackdrop.style.zIndex = '24';
}

// ── Guide Modal ─────────────────────────────────────────────────────────────

function setupGuide() {
  var overlay = document.getElementById('guide-overlay');
  var btn = document.getElementById('guide-btn');
  var closeBtn = document.getElementById('guide-close');

  btn.addEventListener('click', function() {
    overlay.style.display = 'flex';
    // Force reflow so transition fires
    overlay.offsetHeight;
    overlay.classList.add('open');
  });

  function closeGuide() {
    overlay.classList.remove('open');
    setTimeout(function() {
      overlay.style.display = 'none';
    }, 400);
  }

  closeBtn.addEventListener('click', closeGuide);
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) closeGuide();
  });
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && overlay.classList.contains('open')) closeGuide();
  });
}

// ── Stormlight Particle System ──────────────────────────────────────────────

class StormParticles {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.particles = [];
    this.running = true;
    this.resize();
    window.addEventListener('resize', () => this.resize());
    document.addEventListener('visibilitychange', () => {
      this.running = !document.hidden;
      if (this.running) this.loop();
    });
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  init(count) {
    this.particles = [];
    for (let i = 0; i < count; i++) {
      this.particles.push(this.spawn(true));
    }
    this.loop();
  }

  spawn(randomY) {
    const layer = Math.random() > 0.5 ? 0 : 1;
    return {
      x: Math.random() * this.canvas.width,
      y: randomY ? Math.random() * this.canvas.height : this.canvas.height + 20,
      vy: -(0.12 + Math.random() * 0.28) * (layer === 0 ? 0.5 : 1),
      wobbleSpeed: 0.0008 + Math.random() * 0.002,
      wobbleAmp: 12 + Math.random() * 25,
      phase: Math.random() * Math.PI * 2,
      size: layer === 0 ? (2.5 + Math.random() * 3) : (1 + Math.random() * 2),
      opacity: layer === 0 ? (0.035 + Math.random() * 0.05) : (0.05 + Math.random() * 0.09),
      time: Math.random() * 10000,
    };
  }

  loop() {
    if (!this.running) return;
    const { ctx, canvas, particles } = this;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const p of particles) {
      p.time += 1;
      p.y += p.vy;
      const wx = Math.sin(p.time * p.wobbleSpeed + p.phase) * p.wobbleAmp;
      if (p.y < -30) {
        p.y = canvas.height + 30;
        p.x = Math.random() * canvas.width;
        p.phase = Math.random() * Math.PI * 2;
      }
      ctx.beginPath();
      ctx.arc(p.x + wx, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(200,223,255,' + p.opacity + ')';
      ctx.fill();
    }
    requestAnimationFrame(() => this.loop());
  }
}

// ── Gemstone Path Generator ─────────────────────────────────────────────────

function gemPath(r, facets) {
  const n = facets || 6;
  const offset = -Math.PI / 2;
  const pts = [];
  for (let i = 0; i < n; i++) {
    const a = (2 * Math.PI / n) * i + offset;
    pts.push((r * Math.cos(a)).toFixed(2) + ',' + (r * Math.sin(a)).toFixed(2));
  }
  return 'M' + pts.join('L') + 'Z';
}

// ── State ───────────────────────────────────────────────────────────────────

let graph, entries;
var similarity = {};
let simulation;
let focusedNode = null;
let activeFilters = new Set(Object.keys(GEM_COLORS));

// ── Init ────────────────────────────────────────────────────────────────────

async function init() {
  const startTime = Date.now();

  // Start particles immediately
  const storm = new StormParticles(document.getElementById('particles'));
  storm.init(70);

  // Load data
  const basePath = window.location.pathname.replace(/\/[^\/]*$/, '');
  const [graphResp, entriesResp, similarityResp] = await Promise.all([
    fetch(basePath + '/data/graph.json').then(function(r) { return r.json(); }),
    fetch(basePath + '/data/entries.json').then(function(r) { return r.json(); }),
    fetch(basePath + '/data/similarity.json').then(function(r) { return r.json(); }).catch(function() { return {}; }),
  ]);
  graph = graphResp;
  entries = entriesResp;
  similarity = similarityResp;

  // Filter book nodes
  graph.nodes = graph.nodes.filter(function(n) { return n.type !== 'book'; });
  var nodeIds = new Set(graph.nodes.map(function(n) { return n.id; }));
  graph.edges = graph.edges.filter(function(e) { return nodeIds.has(e.source) && nodeIds.has(e.target); });

  document.getElementById('node-count').textContent = graph.nodes.length;
  document.getElementById('edge-count').textContent = graph.edges.length;

  // Build graph while loading screen is visible
  buildGraph();
  buildFilters();
  setupSearch();
  setupPanel();
  buildExplicitTagsByEntry();
  buildBaselineConnected();
  setupEmbeddingControls();
  setupEdgeLayerToggle();
  setupReviewPanel();
  setupBackdrops();
  setupGuide();

  // Ensure minimum 2.2s loading for animation
  const elapsed = Date.now() - startTime;
  if (elapsed < 2200) {
    await new Promise(function(r) { return setTimeout(r, 2200 - elapsed); });
  }

  // Transition out
  var loading = document.getElementById('loading');
  loading.classList.add('fade-out');
  await new Promise(function(r) { return setTimeout(r, 600); });
  loading.style.display = 'none';

  // Fade in graph and UI
  document.getElementById('graph-container').style.opacity = '1';
  document.getElementById('header').style.opacity = '1';
  document.getElementById('filters').style.opacity = '1';
  document.getElementById('info').style.opacity = '1';
  document.getElementById('embedding-controls-bar').style.opacity = '1';
}

// ── Build Graph ─────────────────────────────────────────────────────────────

function buildGraph() {
  var svg = d3.select('#graph-svg');
  var width = window.innerWidth;
  var height = window.innerHeight;
  var defs = svg.append('defs');

  // Soft blur filter for glow circles
  var blurFilter = defs.append('filter')
    .attr('id', 'soft-blur')
    .attr('x', '-100%').attr('y', '-100%')
    .attr('width', '300%').attr('height', '300%');
  blurFilter.append('feGaussianBlur')
    .attr('stdDeviation', '5');

  // Radial gradients for gemstone fills
  Object.keys(GEM_COLORS).forEach(function(type) {
    var grad = defs.append('radialGradient')
      .attr('id', 'gem-fill-' + type)
      .attr('cx', '35%').attr('cy', '30%').attr('r', '65%');
    grad.append('stop').attr('offset', '0%').attr('stop-color', GEM_HIGHLIGHT[type]);
    grad.append('stop').attr('offset', '100%').attr('stop-color', GEM_COLORS[type]);
  });

  // Scales
  var sizeScale = d3.scaleSqrt()
    .domain([1, d3.max(graph.nodes, function(d) { return d.entryCount; })])
    .range([4, 24]);

  var edgeScale = d3.scaleLinear()
    .domain([2, d3.max(graph.edges, function(d) { return d.weight; })])
    .range([0.3, 2.5]);

  // Zoom
  var zoom = d3.zoom()
    .scaleExtent([0.1, 8])
    .on('zoom', function(event) { container.attr('transform', event.transform); });
  svg.call(zoom);
  svg.on('click', function(event) {
    if (event.target === svg.node()) unfocus();
  });

  var container = svg.append('g');

  // Edges
  var linkGroup = container.append('g').attr('class', 'links');
  var links = linkGroup.selectAll('line')
    .data(graph.edges)
    .join('line')
    .attr('stroke', 'rgba(200,223,255,0.06)')
    .attr('stroke-width', function(d) { return edgeScale(d.weight); })
    .attr('stroke-opacity', 1);

  // Nodes
  var nodeGroup = container.append('g').attr('class', 'nodes');
  var nodes = nodeGroup.selectAll('g')
    .data(graph.nodes)
    .join('g')
    .attr('cursor', 'pointer')
    .call(d3.drag()
      .on('start', dragStart)
      .on('drag', dragging)
      .on('end', dragEnd));

  // Glow circle (behind gemstone)
  nodes.append('circle')
    .attr('class', 'gem-glow')
    .attr('r', function(d) { return sizeScale(d.entryCount) * 1.8; })
    .attr('fill', function(d) { return GEM_GLOW[d.type]; })
    .attr('fill-opacity', 0.1)
    .attr('filter', 'url(#soft-blur)')
    .attr('pointer-events', 'none');

  // Gemstone node
  nodes.append('path')
    .attr('class', 'gem-node')
    .attr('d', function(d) { return gemPath(sizeScale(d.entryCount), d.entryCount > 80 ? 8 : 6); })
    .attr('fill', function(d) { return 'url(#gem-fill-' + d.type + ')'; })
    .attr('fill-opacity', 0.85)
    .attr('stroke', function(d) { return GEM_GLOW[d.type]; })
    .attr('stroke-width', 0.8)
    .attr('stroke-opacity', 0.3);

  // Labels
  nodes.filter(function(d) { return d.entryCount >= 30; })
    .append('text')
    .attr('class', 'gem-label')
    .text(function(d) { return d.label; })
    .attr('text-anchor', 'middle')
    .attr('dy', function(d) { return sizeScale(d.entryCount) + 14; })
    .attr('font-size', function(d) { return Math.min(11, 7 + d.entryCount / 50); })
    .attr('fill', '#C8DFFF')
    .attr('fill-opacity', 0.75)
    .attr('pointer-events', 'none')
    .attr('font-family', 'system-ui, sans-serif');

  // Tooltip
  var tooltip = d3.select('#tooltip');
  nodes.on('mouseenter', function(event, d) {
    var nameEl = document.createElement('div');
    nameEl.className = 'tt-name';
    nameEl.style.color = GEM_GLOW[d.type];
    nameEl.textContent = d.label;

    var metaEl = document.createElement('div');
    metaEl.className = 'tt-meta';
    metaEl.textContent = GEM_NAMES[d.type] + ' \u00B7 ' + d.entryCount + ' entries';

    var container = tooltip.node();
    container.textContent = '';
    container.appendChild(nameEl);
    container.appendChild(metaEl);
    tooltip.style('display', 'block');
  })
  .on('mousemove', function(event) {
    tooltip.style('left', (event.clientX + 14) + 'px')
      .style('top', (event.clientY - 10) + 'px');
  })
  .on('mouseleave', function() { tooltip.style('display', 'none'); });

  // Mobile tooltip: show briefly on touch
  nodes.on('touchstart', function(event, d) {
    if (!isMobile()) return;
    var touch = event.touches[0];
    var nameEl = document.createElement('div');
    nameEl.className = 'tt-name';
    nameEl.style.color = GEM_GLOW[d.type];
    nameEl.textContent = d.label;
    var metaEl = document.createElement('div');
    metaEl.className = 'tt-meta';
    metaEl.textContent = GEM_NAMES[d.type] + ' \u00B7 ' + d.entryCount + ' entries';
    var ttNode = tooltip.node();
    ttNode.textContent = '';
    ttNode.appendChild(nameEl);
    ttNode.appendChild(metaEl);
    tooltip.style('display', 'block')
      .style('left', (touch.clientX + 14) + 'px')
      .style('top', (touch.clientY - 10) + 'px');
    clearTimeout(window._tooltipTimer);
    window._tooltipTimer = setTimeout(function() {
      tooltip.style('display', 'none');
    }, 2000);
  }, { passive: true });

  // Click to focus
  nodes.on('click', function(event, d) {
    event.stopPropagation();
    focusNode(d.id);
  });

  // Simulation
  simulation = d3.forceSimulation(graph.nodes)
    .force('link', d3.forceLink(graph.edges).id(function(d) { return d.id; }).distance(80).strength(function(d) { return Math.min(0.3, d.weight / 50); }))
    .force('charge', d3.forceManyBody().strength(-120).distanceMax(400))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(function(d) { return sizeScale(d.entryCount) + 4; }))
    .on('tick', function() {
      links
        .attr('x1', function(d) { return d.source.x; }).attr('y1', function(d) { return d.source.y; })
        .attr('x2', function(d) { return d.target.x; }).attr('y2', function(d) { return d.target.y; });
      nodes.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
    });

  // Store refs
  window._nodes = nodes;
  window._links = links;
  window._sizeScale = sizeScale;
  window._zoom = zoom;
  window._svg = svg;
  window._container = container;

  function dragStart(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x; d.fy = d.y;
  }
  function dragging(event, d) { d.fx = event.x; d.fy = event.y; }
  function dragEnd(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null; d.fy = null;
  }
}

// ── Focus / Unfocus ─────────────────────────────────────────────────────────

function getNeighbors(nodeId) {
  var neighbors = new Set();
  var edgeData = [];
  graph.edges.forEach(function(e) {
    var src = typeof e.source === 'object' ? e.source.id : e.source;
    var tgt = typeof e.target === 'object' ? e.target.id : e.target;
    if (src === nodeId) { neighbors.add(tgt); edgeData.push(e); }
    if (tgt === nodeId) { neighbors.add(src); edgeData.push(e); }
  });
  return { neighbors: neighbors, edgeData: edgeData };
}

function focusNode(nodeId) {
  focusedNode = nodeId;
  var result = getNeighbors(nodeId);
  var neighbors = result.neighbors;
  var edgeData = result.edgeData;
  var node = graph.nodes.find(function(n) { return n.id === nodeId; });
  var focusGlow = GEM_GLOW[node.type];

  // Gemstone nodes
  window._nodes.select('.gem-node')
    .transition().duration(300)
    .attr('fill-opacity', function(d) {
      if (d.id === nodeId) return 1;
      if (neighbors.has(d.id)) return 0.85;
      return 0.04;
    })
    .attr('stroke-opacity', function(d) {
      if (d.id === nodeId) return 0.8;
      if (neighbors.has(d.id)) return 0.4;
      return 0.02;
    })
    .attr('transform', function(d) { return d.id === nodeId ? 'scale(1.3)' : 'scale(1)'; });

  // Glow circles
  window._nodes.select('.gem-glow')
    .transition().duration(300)
    .attr('fill-opacity', function(d) {
      if (d.id === nodeId) return 0.3;
      if (neighbors.has(d.id)) return 0.15;
      return 0.01;
    })
    .attr('r', function(d) {
      var base = window._sizeScale(d.entryCount) * 1.8;
      return d.id === nodeId ? base * 1.6 : base;
    });

  // Labels
  window._nodes.select('.gem-label')
    .transition().duration(300)
    .attr('fill-opacity', function(d) { return (d.id === nodeId || neighbors.has(d.id)) ? 0.9 : 0.03; });

  // Edges -- respect type filters
  function linkFilteredOut(d) {
    var srcType = typeof d.source === 'object' ? d.source.type : null;
    var tgtType = typeof d.target === 'object' ? d.target.type : null;
    return !activeFilters.has(srcType) || !activeFilters.has(tgtType);
  }

  window._links
    .attr('stroke', function(d) {
      if (linkFilteredOut(d)) return 'rgba(200,223,255,0.03)';
      var src = typeof d.source === 'object' ? d.source.id : d.source;
      var tgt = typeof d.target === 'object' ? d.target.id : d.target;
      return (src === nodeId || tgt === nodeId) ? focusGlow : 'rgba(200,223,255,0.03)';
    });

  // Pulse connected edges (only if both endpoints are active)
  window._links.filter(function(d) {
    if (linkFilteredOut(d)) return false;
    var src = typeof d.source === 'object' ? d.source.id : d.source;
    var tgt = typeof d.target === 'object' ? d.target.id : d.target;
    return src === nodeId || tgt === nodeId;
  })
    .attr('stroke-opacity', 0.1)
    .transition().duration(350)
    .attr('stroke-opacity', 0.65)
    .transition().duration(500)
    .attr('stroke-opacity', 0.4);

  // Dim unconnected or filtered-out edges
  window._links.filter(function(d) {
    if (linkFilteredOut(d)) return true;
    var src = typeof d.source === 'object' ? d.source.id : d.source;
    var tgt = typeof d.target === 'object' ? d.target.id : d.target;
    return src !== nodeId && tgt !== nodeId;
  })
    .transition().duration(300)
    .attr('stroke-opacity', function(d) { return linkFilteredOut(d) ? 0.02 : 0.3; });

  // Center camera
  if (node && typeof node.x === 'number') {
    var transform = d3.zoomIdentity
      .translate(window.innerWidth / 2, window.innerHeight / 2)
      .scale(1.5)
      .translate(-node.x, -node.y);
    window._svg.transition().duration(750).call(window._zoom.transform, transform);
  }

  showPanel(nodeId, edgeData);
}

function unfocus() {
  focusedNode = null;

  window._nodes.select('.gem-node')
    .transition().duration(300)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.85 : 0.04; })
    .attr('stroke-opacity', function(d) { return activeFilters.has(d.type) ? 0.3 : 0.02; })
    .attr('transform', 'scale(1)');

  window._nodes.select('.gem-glow')
    .transition().duration(300)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.1 : 0.01; })
    .attr('r', function(d) { return window._sizeScale(d.entryCount) * 1.8; });

  window._nodes.select('.gem-label')
    .transition().duration(300)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.75 : 0.03; });

  window._links
    .transition().duration(300)
    .attr('stroke', 'rgba(200,223,255,0.06)')
    .attr('stroke-opacity', function(d) {
      var srcType = typeof d.source === 'object' ? d.source.type : null;
      var tgtType = typeof d.target === 'object' ? d.target.type : null;
      return (activeFilters.has(srcType) && activeFilters.has(tgtType)) ? 1 : 0.02;
    });

  if (implicitLinks) {
    implicitLinks
      .transition().duration(300)
      .attr('stroke-opacity', function(d) {
        var srcType = typeof d.source === 'object' ? d.source.type : null;
        var tgtType = typeof d.target === 'object' ? d.target.type : null;
        if (!activeFilters.has(srcType) || !activeFilters.has(tgtType)) return 0.02;
        return d.type === 'mixed' ? 0.55 : 0.4;
      });
  }

  closePanel();

  window._svg.transition().duration(500)
    .call(window._zoom.transform, d3.zoomIdentity
      .translate(window.innerWidth / 2, window.innerHeight / 2)
      .scale(0.8)
      .translate(-window.innerWidth / 2, -window.innerHeight / 2));
}

// ── Panel ───────────────────────────────────────────────────────────────────

function setupPanel() {
  document.getElementById('panel-close').addEventListener('click', function() { unfocus(); });
}

function showPanel(nodeId, edgeData) {
  var node = graph.nodes.find(function(n) { return n.id === nodeId; });
  var panel = document.getElementById('panel');
  var content = document.getElementById('panel-content');

  // Set panel gem color
  panel.style.setProperty('--panel-gem-color', GEM_COLORS[node.type]);
  panel.style.setProperty('--panel-gem-glow', GEM_GLOW[node.type]);

  // Group connections by type
  var connectionsByType = {};
  edgeData.forEach(function(e) {
    var src = typeof e.source === 'object' ? e.source.id : e.source;
    var tgt = typeof e.target === 'object' ? e.target.id : e.target;
    var otherId = src === nodeId ? tgt : src;
    var other = graph.nodes.find(function(n) { return n.id === otherId; });
    if (!other || !activeFilters.has(other.type)) return;
    if (!connectionsByType[other.type]) connectionsByType[other.type] = [];
    connectionsByType[other.type].push({ node: other, weight: e.weight, entryIds: e.entryIds });
  });

  Object.values(connectionsByType).forEach(function(arr) { arr.sort(function(a, b) { return b.weight - a.weight; }); });

  // Build panel DOM safely
  content.textContent = '';

  // Header
  var h2 = document.createElement('h2');
  h2.textContent = node.label;
  content.appendChild(h2);

  var badge = document.createElement('div');
  badge.className = 'gem-badge';
  badge.style.background = GEM_COLORS[node.type] + '20';
  badge.style.color = GEM_GLOW[node.type];
  badge.style.border = '1px solid ' + GEM_COLORS[node.type] + '40';
  badge.textContent = GEM_NAMES[node.type];
  content.appendChild(badge);

  var countDiv = document.createElement('div');
  countDiv.className = 'panel-entry-count';
  countDiv.textContent = node.entryCount + ' WoB entries';
  content.appendChild(countDiv);

  // "Browse all entries" button -- finds entries by tag
  var browseBtn = document.createElement('button');
  browseBtn.className = 'browse-all-btn';
  browseBtn.textContent = 'Browse all ' + node.entryCount + ' entries \u2192';
  browseBtn.addEventListener('click', function() {
    showAllEntries(nodeId);
  });
  content.appendChild(browseBtn);

  var divider = document.createElement('div');
  divider.className = 'panel-divider';
  content.appendChild(divider);

  // Connections list
  var connSection = document.createElement('div');
  connSection.className = 'connections-section';
  connSection.id = 'connections-list';

  var typeOrder = ['character', 'shard', 'magic', 'world', 'concept'];
  typeOrder.forEach(function(type) {
    var conns = connectionsByType[type];
    if (!conns || conns.length === 0) return;

    var h3 = document.createElement('h3');
    h3.style.color = GEM_GLOW[type];
    h3.textContent = TYPE_LABELS[type] + ' (' + conns.length + ')';
    connSection.appendChild(h3);

    conns.forEach(function(c) {
      var item = document.createElement('div');
      item.className = 'connection-item';
      item.dataset.node = c.node.id;
      item.dataset.entries = JSON.stringify(c.entryIds);

      var left = document.createElement('div');
      left.className = 'conn-left';

      var gem = document.createElement('span');
      gem.className = 'conn-gem';
      gem.style.background = GEM_COLORS[c.node.type];
      left.appendChild(gem);

      var nameSpan = document.createElement('span');
      nameSpan.style.color = GEM_GLOW[c.node.type];
      nameSpan.textContent = c.node.label;
      left.appendChild(nameSpan);

      var weight = document.createElement('span');
      weight.className = 'connection-weight';
      weight.style.background = GEM_COLORS[c.node.type] + '15';
      weight.style.color = GEM_GLOW[c.node.type];
      weight.textContent = c.weight;

      item.appendChild(left);
      item.appendChild(weight);
      item.addEventListener('click', function() {
        showEntries(nodeId, c.node.id, c.entryIds);
      });
      connSection.appendChild(item);
    });
  });

  content.appendChild(connSection);

  // Similar Entities section
  var simData = similarity[nodeId];
  if (simData && simData.length > 0) {
    var simDivider = document.createElement('div');
    simDivider.className = 'panel-divider';
    content.appendChild(simDivider);

    var simSection = document.createElement('div');
    simSection.className = 'similar-section';

    var simH3 = document.createElement('h3');
    simH3.style.color = 'var(--stormlight)';
    simH3.style.fontSize = '0.7rem';
    simH3.style.textTransform = 'uppercase';
    simH3.style.letterSpacing = '0.15em';
    simH3.style.marginBottom = '0.6rem';
    simH3.style.opacity = '0.7';
    simH3.textContent = 'Semantically Similar';
    simSection.appendChild(simH3);

    simData.forEach(function(s) {
      var simNode = graph.nodes.find(function(n) { return n.id === s.id; });
      if (!simNode || !activeFilters.has(simNode.type)) return;

      var item = document.createElement('div');
      item.className = 'connection-item';

      var left = document.createElement('div');
      left.className = 'conn-left';

      var gem = document.createElement('span');
      gem.className = 'conn-gem';
      gem.style.background = GEM_COLORS[simNode.type];
      left.appendChild(gem);

      var nameSpan = document.createElement('span');
      nameSpan.style.color = GEM_GLOW[simNode.type];
      nameSpan.textContent = simNode.label;
      left.appendChild(nameSpan);

      var score = document.createElement('span');
      score.className = 'connection-weight';
      score.style.background = 'rgba(200, 220, 255, 0.08)';
      score.style.color = 'var(--stormlight)';
      score.textContent = (s.score * 100).toFixed(0) + '%';

      item.appendChild(left);
      item.appendChild(score);
      item.addEventListener('click', function() {
        focusNode(s.id);
      });
      simSection.appendChild(item);
    });

    content.appendChild(simSection);
  }

  var entriesSection = document.createElement('div');
  entriesSection.id = 'entries-section';
  content.appendChild(entriesSection);

  panel.classList.add('open');
  showBackdrop(_panelBackdrop);
}

function showEntries(nodeId, otherNodeId, entryIds) {
  var node = graph.nodes.find(function(n) { return n.id === nodeId; });
  var other = graph.nodes.find(function(n) { return n.id === otherNodeId; });
  var section = document.getElementById('entries-section');
  section.textContent = '';

  // Header
  var header = document.createElement('div');
  header.className = 'entries-header';

  var h3 = document.createElement('h3');
  h3.textContent = node.label + ' \u2194 ' + other.label;
  header.appendChild(h3);

  var backBtn = document.createElement('button');
  backBtn.className = 'entries-back';
  backBtn.textContent = '\u2190 Back';
  backBtn.addEventListener('click', function() {
    section.style.display = 'none';
    document.getElementById('connections-list').style.display = 'block';
  });
  header.appendChild(backBtn);
  section.appendChild(header);

  // Entries
  entryIds.forEach(function(eid) {
    var entry = entries[eid];
    if (!entry) return;
    var lines = entry.lines || [];
    var collapsed = lines.length > 3;

    var card = document.createElement('div');
    card.className = 'wob-entry';

    // Event line
    var eventDiv = document.createElement('div');
    eventDiv.className = 'wob-event';
    var dot = document.createElement('span');
    dot.className = 'wob-event-dot';
    eventDiv.appendChild(dot);
    var eventText = document.createTextNode(entry.event + ' \u00B7 ' + entry.date);
    eventDiv.appendChild(eventText);
    card.appendChild(eventDiv);

    // Visible lines
    var visibleLines = collapsed ? lines.slice(0, 3) : lines;
    visibleLines.forEach(function(line) {
      card.appendChild(createLineEl(line));
    });

    // Hidden lines + expand button
    if (collapsed) {
      var hiddenDiv = document.createElement('div');
      hiddenDiv.style.display = 'none';
      lines.slice(3).forEach(function(line) {
        hiddenDiv.appendChild(createLineEl(line));
      });
      card.appendChild(hiddenDiv);

      var expandBtn = document.createElement('button');
      expandBtn.className = 'wob-expand';
      expandBtn.textContent = 'Show ' + (lines.length - 3) + ' more lines';
      expandBtn.addEventListener('click', function() {
        if (hiddenDiv.style.display === 'none') {
          hiddenDiv.style.display = 'block';
          expandBtn.textContent = 'Show less';
        } else {
          hiddenDiv.style.display = 'none';
          expandBtn.textContent = 'Show ' + (lines.length - 3) + ' more lines';
        }
      });
      card.appendChild(expandBtn);
    }

    // Tags
    var tags = (entry.tags || []).slice(0, 8);
    if (tags.length) {
      var tagsDiv = document.createElement('div');
      tagsDiv.className = 'wob-tags';
      tags.forEach(function(t) {
        var tag = document.createElement('span');
        tag.className = 'wob-tag';
        tag.textContent = t;
        tagsDiv.appendChild(tag);
      });
      card.appendChild(tagsDiv);
    }

    section.appendChild(card);
  });

  section.style.display = 'block';
  document.getElementById('connections-list').style.display = 'none';
}

function createLineEl(line) {
  var div = document.createElement('div');
  div.className = 'wob-line';
  var speaker = document.createElement('span');
  var isBrandon = line.speaker.toLowerCase().indexOf('brandon') >= 0 || line.speaker.toLowerCase().indexOf('sanderson') >= 0;
  speaker.className = 'wob-speaker ' + (isBrandon ? 'brandon' : 'questioner');
  speaker.textContent = line.speaker + ':';
  div.appendChild(speaker);
  // The text from Arcanum may contain HTML formatting (emphasis, links)
  // We create a span and set textContent to safely render it as plain text
  var textSpan = document.createElement('span');
  textSpan.textContent = ' ' + stripHtml(line.text);
  div.appendChild(textSpan);
  return div;
}

function stripHtml(html) {
  var tmp = document.createElement('div');
  tmp.textContent = html;
  // If the text had actual HTML tags, parse them out
  var decoded = tmp.textContent;
  var parser = document.createElement('div');
  parser.innerHTML = decoded;
  return parser.textContent || parser.innerText || decoded;
}

function showAllEntries(nodeId) {
  var node = graph.nodes.find(function(n) { return n.id === nodeId; });
  var section = document.getElementById('entries-section');
  section.textContent = '';

  // Find all entries tagged with this node's id
  var matchingEntries = [];
  Object.keys(entries).forEach(function(eid) {
    var entry = entries[eid];
    if (entry.tags && entry.tags.indexOf(node.id) >= 0) {
      matchingEntries.push(entry);
    }
  });

  // Sort by date descending
  matchingEntries.sort(function(a, b) {
    return (b.date || '').localeCompare(a.date || '');
  });

  // Header
  var header = document.createElement('div');
  header.className = 'entries-header';

  var h3 = document.createElement('h3');
  h3.textContent = 'All entries for ' + node.label + ' (' + matchingEntries.length + ')';
  header.appendChild(h3);

  var backBtn = document.createElement('button');
  backBtn.className = 'entries-back';
  backBtn.textContent = '\u2190 Back';
  backBtn.addEventListener('click', function() {
    section.style.display = 'none';
    document.getElementById('connections-list').style.display = 'block';
  });
  header.appendChild(backBtn);
  section.appendChild(header);

  // Render entries
  matchingEntries.forEach(function(entry) {
    var lines = entry.lines || [];
    var collapsed = lines.length > 3;

    var card = document.createElement('div');
    card.className = 'wob-entry';

    var eventDiv = document.createElement('div');
    eventDiv.className = 'wob-event';
    var dot = document.createElement('span');
    dot.className = 'wob-event-dot';
    eventDiv.appendChild(dot);
    eventDiv.appendChild(document.createTextNode(entry.event + ' \u00B7 ' + entry.date));
    card.appendChild(eventDiv);

    var visibleLines = collapsed ? lines.slice(0, 3) : lines;
    visibleLines.forEach(function(line) { card.appendChild(createLineEl(line)); });

    if (collapsed) {
      var hiddenDiv = document.createElement('div');
      hiddenDiv.style.display = 'none';
      lines.slice(3).forEach(function(line) { hiddenDiv.appendChild(createLineEl(line)); });
      card.appendChild(hiddenDiv);

      var expandBtn = document.createElement('button');
      expandBtn.className = 'wob-expand';
      expandBtn.textContent = 'Show ' + (lines.length - 3) + ' more lines';
      expandBtn.addEventListener('click', function() {
        if (hiddenDiv.style.display === 'none') {
          hiddenDiv.style.display = 'block';
          expandBtn.textContent = 'Show less';
        } else {
          hiddenDiv.style.display = 'none';
          expandBtn.textContent = 'Show ' + (lines.length - 3) + ' more lines';
        }
      });
      card.appendChild(expandBtn);
    }

    var tags = (entry.tags || []).slice(0, 8);
    if (tags.length) {
      var tagsDiv = document.createElement('div');
      tagsDiv.className = 'wob-tags';
      tags.forEach(function(t) {
        var tag = document.createElement('span');
        tag.className = 'wob-tag';
        tag.textContent = t;
        tagsDiv.appendChild(tag);
      });
      card.appendChild(tagsDiv);
    }

    section.appendChild(card);
  });

  section.style.display = 'block';
  document.getElementById('connections-list').style.display = 'none';
}

function closePanel() {
  document.getElementById('panel').classList.remove('open');
  hideBackdrop(_panelBackdrop);
}

// ── Filters ─────────────────────────────────────────────────────────────────

function buildFilters() {
  var container = document.getElementById('filters');
  Object.keys(TYPE_LABELS).forEach(function(type) {
    var btn = document.createElement('button');
    btn.className = 'filter-btn';
    btn.dataset.type = type;

    var gem = document.createElement('span');
    gem.className = 'filter-gem';
    gem.style.background = GEM_COLORS[type];
    btn.appendChild(gem);

    var label = document.createTextNode(TYPE_LABELS[type]);
    btn.appendChild(label);

    btn.addEventListener('mouseenter', function() {
      if (!btn.classList.contains('off')) {
        btn.style.borderColor = GEM_COLORS[type];
      }
    });
    btn.addEventListener('mouseleave', function() {
      btn.style.borderColor = '';
    });
    btn.addEventListener('click', function() { toggleFilter(type, btn); });
    container.appendChild(btn);
  });
}

function toggleFilter(type, btn) {
  if (activeFilters.has(type)) {
    activeFilters.delete(type);
    btn.classList.add('off');
  } else {
    activeFilters.add(type);
    btn.classList.remove('off');
  }
  applyFilters();
}

function applyFilters() {
  window._nodes.select('.gem-node')
    .transition().duration(200)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.85 : 0.04; })
    .attr('stroke-opacity', function(d) { return activeFilters.has(d.type) ? 0.3 : 0.02; });
  window._nodes.select('.gem-glow')
    .transition().duration(200)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.1 : 0.01; });
  window._nodes.select('.gem-label')
    .transition().duration(200)
    .attr('fill-opacity', function(d) { return activeFilters.has(d.type) ? 0.75 : 0.03; });

  // Hide edges connected to filtered-out node types
  function edgeVisible(d) {
    var srcType = typeof d.source === 'object' ? d.source.type : null;
    var tgtType = typeof d.target === 'object' ? d.target.type : null;
    return activeFilters.has(srcType) && activeFilters.has(tgtType);
  }
  if (window._links) {
    window._links
      .transition().duration(200)
      .attr('stroke-opacity', function(d) { return edgeVisible(d) ? 1 : 0.02; });
  }
  if (implicitLinks) {
    implicitLinks
      .transition().duration(200)
      .attr('stroke-opacity', function(d) {
        if (!edgeVisible(d)) return 0.02;
        return d.type === 'mixed' ? 0.55 : 0.4;
      });
  }
}

// ── Search ──────────────────────────────────────────────────────────────────

function setupSearch() {
  var input = document.getElementById('search-input');
  var suggestions = document.getElementById('search-suggestions');
  var clearBtn = document.getElementById('search-clear');
  var activeIndex = -1;

  input.addEventListener('input', function() {
    var q = input.value.trim().toLowerCase();
    clearBtn.style.display = q ? 'block' : 'none';
    if (q.length < 1) { suggestions.style.display = 'none'; return; }

    var matches = graph.nodes
      .filter(function(n) { return n.id.indexOf(q) >= 0 || n.label.toLowerCase().indexOf(q) >= 0; })
      .sort(function(a, b) { return b.entryCount - a.entryCount; })
      .slice(0, 15);

    if (matches.length === 0) { suggestions.style.display = 'none'; return; }

    activeIndex = -1;
    suggestions.textContent = '';

    matches.forEach(function(m, i) {
      var div = document.createElement('div');
      div.className = 'suggestion';
      div.dataset.id = m.id;
      div.dataset.index = i;

      var nameSpan = document.createElement('span');
      nameSpan.style.color = GEM_GLOW[m.type];
      nameSpan.textContent = m.label;
      div.appendChild(nameSpan);

      var tagSpan = document.createElement('span');
      tagSpan.className = 'tag-type';
      tagSpan.style.background = GEM_COLORS[m.type] + '20';
      tagSpan.style.color = GEM_GLOW[m.type];
      tagSpan.textContent = GEM_NAMES[m.type];
      div.appendChild(tagSpan);

      div.addEventListener('click', function() {
        input.value = '';
        clearBtn.style.display = 'none';
        suggestions.style.display = 'none';
        focusNode(m.id);
      });
      suggestions.appendChild(div);
    });

    suggestions.style.display = 'block';
  });

  input.addEventListener('keydown', function(e) {
    var items = suggestions.querySelectorAll('.suggestion');
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIndex = Math.min(activeIndex + 1, items.length - 1);
      items.forEach(function(el, i) { el.classList.toggle('active', i === activeIndex); });
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIndex = Math.max(activeIndex - 1, 0);
      items.forEach(function(el, i) { el.classList.toggle('active', i === activeIndex); });
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (activeIndex >= 0 && items[activeIndex]) items[activeIndex].click();
      else if (items.length > 0) items[0].click();
    } else if (e.key === 'Escape') {
      suggestions.style.display = 'none';
      input.blur();
      unfocus();
    }
  });

  clearBtn.addEventListener('click', function() {
    input.value = '';
    clearBtn.style.display = 'none';
    suggestions.style.display = 'none';
    unfocus();
  });

  document.addEventListener('click', function(e) {
    if (!e.target.closest('#search-box')) suggestions.style.display = 'none';
  });
}

// ── Keyboard shortcuts ──────────────────────────────────────────────────────

document.addEventListener('keydown', function(e) {
  if (e.key === '/' && !e.target.matches('input')) {
    e.preventDefault();
    document.getElementById('search-input').focus();
  }
  if (e.key === 'Escape') unfocus();
});

// ── Embedding Controls ──────────────────────────────────────────────────────

var scoresData = null;
var explicitTagsByEntry = {};
var baselineConnected = {};

function buildExplicitTagsByEntry() {
  var eids = Object.keys(entries);
  for (var i = 0; i < eids.length; i++) {
    var eid = eids[i];
    var entry = entries[eid];
    if (entry.tags && entry.tags.length > 0) {
      explicitTagsByEntry[eid] = entry.tags;
    }
  }
}

function buildBaselineConnected() {
  // Entries that appear in at least one edge in graph.json
  for (var i = 0; i < graph.edges.length; i++) {
    var e = graph.edges[i];
    var src = typeof e.source === 'object' ? e.source.id : e.source;
    var tgt = typeof e.target === 'object' ? e.target.id : e.target;
    baselineConnected[src] = true;
    baselineConnected[tgt] = true;
  }
}

function setupEmbeddingControls() {
  var tuningToggle = document.getElementById('tuning-toggle-btn');
  var tuningPanel = document.getElementById('tuning-panel');
  var applyBtn = document.getElementById('apply-embeddings-btn');
  var statsEl = document.getElementById('embedding-stats');

  // Slider value labels: wire up input events
  var sliders = [
    { id: 'slider-calibration-percentile', valueId: 'value-calibration-percentile', format: function(v) { return String(parseInt(v, 10)); } },
    { id: 'slider-min-specificity',        valueId: 'value-min-specificity',        format: function(v) { return parseFloat(v).toFixed(1); } },
    { id: 'slider-confidence-margin',      valueId: 'value-confidence-margin',      format: function(v) { return parseFloat(v).toFixed(2); } },
    { id: 'slider-min-edge-weight',        valueId: 'value-min-edge-weight',        format: function(v) { return String(parseInt(v, 10)); } }
  ];

  for (var i = 0; i < sliders.length; i++) {
    (function(s) {
      var slider = document.getElementById(s.id);
      var valueEl = document.getElementById(s.valueId);
      slider.addEventListener('input', function() {
        valueEl.textContent = s.format(slider.value);
      });
    })(sliders[i]);
  }

  // Toggle tuning panel
  tuningToggle.addEventListener('click', function() {
    var isOpen = tuningPanel.classList.contains('open');
    if (isOpen) {
      tuningPanel.classList.remove('open');
      tuningToggle.textContent = 'Tune';
    } else {
      tuningPanel.classList.add('open');
      tuningToggle.textContent = 'Hide';
    }
  });

  // Apply button
  applyBtn.addEventListener('click', function() {
    applyBtn.disabled = true;
    applyBtn.textContent = 'Computing...';
    statsEl.textContent = 'Loading scores...';

    // Use setTimeout to allow UI to update before heavy computation
    setTimeout(function() {
      loadScoresAndCompute(applyBtn, statsEl);
    }, 50);
  });
}

function loadScoresAndCompute(applyBtn, statsEl) {
  var basePath = window.location.pathname.replace(/\/[^\/]*$/, '');

  function runCompute() {
    // Read settings from sliders
    var settings = {
      calibrationPercentile: parseInt(document.getElementById('slider-calibration-percentile').value, 10),
      minSpecificity: parseFloat(document.getElementById('slider-min-specificity').value),
      confidenceMargin: parseFloat(document.getElementById('slider-confidence-margin').value),
      mustBridge: document.getElementById('checkbox-must-bridge').checked,
      minEdgeWeight: parseInt(document.getElementById('slider-min-edge-weight').value, 10)
    };

    try {
      var result = computeImplicitTags(scoresData, explicitTagsByEntry, baselineConnected, settings);
      var s = result.stats;

      statsEl.textContent = s.totalTags + ' tags, ' +
        s.entitiesConsidered + ' entities, ' +
        s.totalEdges + ' edges (' +
        s.implicitEdges + ' implicit, ' +
        s.mixedEdges + ' mixed)';

      // Store result globally for Task 5 integration
      window._lastImplicitResult = result;

      // Render hypothesis layer (implicit edges) and populate review panel
      renderImplicitEdges(result);
      populateReviewPanel(result);

      // Show edge layer toggle and review button
      document.getElementById('edge-layer-toggle').classList.add('visible');
      document.getElementById('review-toggle-btn').classList.add('visible');

    } catch (err) {
      statsEl.textContent = 'Error: ' + err.message;
    }

    applyBtn.disabled = false;
    applyBtn.textContent = 'Apply';
  }

  // Load scores.json if not already cached
  if (scoresData) {
    runCompute();
  } else {
    fetch(basePath + '/data/scores.json')
      .then(function(r) {
        if (!r.ok) throw new Error('HTTP ' + r.status);
        return r.json();
      })
      .then(function(data) {
        scoresData = data;
        statsEl.textContent = 'Computing...';
        // Another setTimeout so UI updates before heavy computation
        setTimeout(runCompute, 50);
      })
      .catch(function(err) {
        statsEl.textContent = 'Failed to load scores: ' + err.message;
        applyBtn.disabled = false;
        applyBtn.textContent = 'Apply';
      });
  }
}

// ── Hypothesis Layer: Implicit Edges ─────────────────────────────────────────

var implicitLinkGroup = null;
var implicitLinks = null;
var _originalTick = null;

function renderImplicitEdges(result) {
  var container = window._container;
  if (!container) return;

  // Remove previous implicit edges if any
  if (implicitLinkGroup) {
    implicitLinkGroup.remove();
  }

  // Filter edges to only implicit and mixed types
  var implicitEdges = [];
  for (var i = 0; i < result.edges.length; i++) {
    var e = result.edges[i];
    if (e.type === 'implicit' || e.type === 'mixed') {
      implicitEdges.push(e);
    }
  }

  if (implicitEdges.length === 0) return;

  // Build a map from entity id to simulation node for position lookup
  var nodeMap = {};
  for (var i = 0; i < graph.nodes.length; i++) {
    nodeMap[graph.nodes[i].id] = graph.nodes[i];
  }

  // Filter edges to only those whose source and target exist in the graph
  var validEdges = [];
  for (var i = 0; i < implicitEdges.length; i++) {
    var e = implicitEdges[i];
    if (nodeMap[e.source] && nodeMap[e.target]) {
      validEdges.push({
        source: nodeMap[e.source],
        target: nodeMap[e.target],
        weight: e.weight,
        type: e.type,
        entryIds: e.entryIds
      });
    }
  }

  // Insert implicit edge group before the nodes group (so edges are behind nodes)
  var nodesGroup = container.select('g.nodes');
  implicitLinkGroup = container.insert('g', function() { return nodesGroup.node(); })
    .attr('class', 'implicit-links');

  implicitLinks = implicitLinkGroup.selectAll('line')
    .data(validEdges)
    .join('line')
    .attr('class', 'implicit-edge')
    .attr('stroke', 'var(--gem-heliodor-glow)')
    .attr('stroke-width', function(d) { return Math.max(0.5, Math.min(2, d.weight / 3)); })
    .attr('stroke-opacity', function(d) { return d.type === 'mixed' ? 0.55 : 0.4; })
    .attr('stroke-dasharray', '6,4')
    .attr('x1', function(d) { return d.source.x || 0; })
    .attr('y1', function(d) { return d.source.y || 0; })
    .attr('x2', function(d) { return d.target.x || 0; })
    .attr('y2', function(d) { return d.target.y || 0; });

  // Add tooltip behavior for implicit edges
  var tooltip = d3.select('#tooltip');
  implicitLinks
    .style('pointer-events', 'stroke')
    .on('mouseenter', function(event, d) {
      var srcLabel = d.source.label || d.source.id;
      var tgtLabel = d.target.label || d.target.id;

      var nameEl = document.createElement('div');
      nameEl.className = 'tt-name';
      nameEl.style.color = 'var(--gem-heliodor-glow)';
      nameEl.textContent = srcLabel + ' - ' + tgtLabel;

      var metaEl = document.createElement('div');
      metaEl.className = 'tt-meta';
      metaEl.textContent = d.type + ' edge / weight ' + d.weight + ' / ' + d.entryIds.length + ' entries';

      var ttNode = tooltip.node();
      ttNode.textContent = '';
      ttNode.appendChild(nameEl);
      ttNode.appendChild(metaEl);
      tooltip.style('display', 'block')
        .style('pointer-events', 'none');
    })
    .on('mousemove', function(event) {
      tooltip.style('left', (event.clientX + 14) + 'px')
        .style('top', (event.clientY - 10) + 'px');
    })
    .on('mouseleave', function() {
      tooltip.style('display', 'none');
    });

  // Store original tick handler once, then extend it with implicit edge updates
  if (!_originalTick) {
    _originalTick = simulation.on('tick');
  }
  simulation.on('tick', function() {
    _originalTick();

    // Update implicit edges
    if (implicitLinks) {
      implicitLinks
        .attr('x1', function(d) { return d.source.x; })
        .attr('y1', function(d) { return d.source.y; })
        .attr('x2', function(d) { return d.target.x; })
        .attr('y2', function(d) { return d.target.y; });
    }
  });

  // Restart simulation with low alpha so it settles without big jumps
  simulation.alpha(0.1).restart();
}

// ── Edge Layer Toggle ────────────────────────────────────────────────────────

function setupEdgeLayerToggle() {
  var radios = document.querySelectorAll('input[name="edge-layer"]');
  for (var i = 0; i < radios.length; i++) {
    radios[i].addEventListener('change', function() {
      applyEdgeLayerFilter(this.value);
    });
  }
}

function applyEdgeLayerFilter(mode) {
  // mode: 'explicit', 'both', 'implicit'
  if (window._links) {
    window._links.attr('visibility', (mode === 'implicit') ? 'hidden' : 'visible');
  }
  if (implicitLinks) {
    implicitLinks.attr('visibility', (mode === 'explicit') ? 'hidden' : 'visible');
  }
}

// ── Review Panel ─────────────────────────────────────────────────────────────

var reviewState = {};  // key: "entity::entryId" -> "confirmed" | "rejected" | undefined

function setupReviewPanel() {
  var toggleBtn = document.getElementById('review-toggle-btn');
  var panel = document.getElementById('review-panel');
  var closeBtn = document.getElementById('review-close-btn');
  var saveBtn = document.getElementById('save-reviews-btn');
  var loadBtn = document.getElementById('load-reviews-btn');
  var sortSelect = document.getElementById('review-sort-select');
  var filterCheckbox = document.getElementById('review-filter-unreviewed');

  toggleBtn.addEventListener('click', function() {
    var isOpen = panel.classList.contains('open');
    if (isOpen) {
      panel.classList.remove('open');
      hideBackdrop(_reviewBackdrop);
    } else {
      panel.classList.add('open');
      showBackdrop(_reviewBackdrop);
    }
  });

  closeBtn.addEventListener('click', function() {
    panel.classList.remove('open');
    hideBackdrop(_reviewBackdrop);
  });

  saveBtn.addEventListener('click', function() {
    exportReviews();
  });

  loadBtn.addEventListener('click', function() {
    loadReviews();
  });

  sortSelect.addEventListener('change', function() {
    if (window._lastImplicitResult) {
      renderReviewRows(window._lastImplicitResult.implicitTags, sortSelect.value, filterCheckbox.checked);
    }
  });

  filterCheckbox.addEventListener('change', function() {
    if (window._lastImplicitResult) {
      renderReviewRows(window._lastImplicitResult.implicitTags, sortSelect.value, filterCheckbox.checked);
    }
  });

  // Event delegation for confirm/reject buttons (avoids 2*N listeners per render)
  var reviewTable = document.getElementById('review-table');
  reviewTable.addEventListener('click', function(e) {
    var btn = e.target;
    if (!btn.classList.contains('review-confirm') && !btn.classList.contains('review-reject')) return;
    var row = btn.closest('.review-row');
    if (!row) return;
    var key = row.dataset.key;
    if (btn.classList.contains('review-confirm')) {
      reviewState[key] = 'confirmed';
      row.classList.remove('rejected');
      row.classList.add('confirmed');
    } else {
      reviewState[key] = 'rejected';
      row.classList.remove('confirmed');
      row.classList.add('rejected');
    }
  });
}

function populateReviewPanel(result) {
  var subtitle = document.getElementById('review-subtitle');
  subtitle.textContent = result.implicitTags.length + ' implicit tags from ' +
    result.stats.entitiesConsidered + ' entities';

  var sortSelect = document.getElementById('review-sort-select');
  var filterCheckbox = document.getElementById('review-filter-unreviewed');
  renderReviewRows(result.implicitTags, sortSelect.value, filterCheckbox.checked);
}

function renderReviewRows(implicitTags, sortMode, filterUnreviewed) {
  var table = document.getElementById('review-table');
  table.textContent = '';

  // Copy and optionally filter
  var sorted = implicitTags.slice();
  if (filterUnreviewed) {
    sorted = sorted.filter(function(tag) {
      var key = tag.entity + '::' + tag.entryId;
      return !reviewState[key];
    });
  }

  // Sort
  if (sortMode === 'score-desc') {
    sorted.sort(function(a, b) { return b.score - a.score; });
  } else if (sortMode === 'score-asc') {
    sorted.sort(function(a, b) { return a.score - b.score; });
  } else if (sortMode === 'entity-asc') {
    sorted.sort(function(a, b) { return a.entity.localeCompare(b.entity); });
  } else if (sortMode === 'status') {
    var statusOrder = { 'pending': 0, 'confirmed': 1, 'rejected': 2 };
    sorted.sort(function(a, b) {
      var sa = reviewState[a.entity + '::' + a.entryId] || 'pending';
      var sb = reviewState[b.entity + '::' + b.entryId] || 'pending';
      var diff = statusOrder[sa] - statusOrder[sb];
      if (diff !== 0) return diff;
      return b.score - a.score;
    });
  }

  for (var i = 0; i < sorted.length; i++) {
    var tag = sorted[i];
    var key = tag.entity + '::' + tag.entryId;
    var row = document.createElement('div');
    row.className = 'review-row';
    row.dataset.key = key;

    // Apply persisted review state
    if (reviewState[key] === 'confirmed') {
      row.classList.add('confirmed');
    } else if (reviewState[key] === 'rejected') {
      row.classList.add('rejected');
    }

    var entitySpan = document.createElement('span');
    entitySpan.className = 'review-entity';
    entitySpan.textContent = tag.entity;
    row.appendChild(entitySpan);

    // Show entry text (truncated) instead of entry ID
    var entrySpan = document.createElement('span');
    entrySpan.className = 'review-entry-id';
    var entryText = '';
    if (entries && entries[tag.entryId]) {
      var entry = entries[tag.entryId];
      if (entry.lines && entry.lines.length > 0) {
        entryText = entry.lines[0].text || '';
      } else if (entry.note) {
        entryText = entry.note;
      }
    }
    if (!entryText) {
      entryText = tag.entryId;
    }
    entrySpan.textContent = entryText.length > 40 ? entryText.substring(0, 40) + '...' : entryText;
    entrySpan.title = entryText;
    row.appendChild(entrySpan);

    var scoreSpan = document.createElement('span');
    scoreSpan.className = 'review-score';
    scoreSpan.textContent = tag.score.toFixed(3);
    row.appendChild(scoreSpan);

    var actionsCell = document.createElement('span');
    actionsCell.className = 'review-actions-cell';

    var confirmBtn = document.createElement('button');
    confirmBtn.className = 'review-confirm';
    confirmBtn.textContent = '\u2713';
    confirmBtn.title = 'Confirm';
    confirmBtn.setAttribute('aria-label', 'Confirm');
    actionsCell.appendChild(confirmBtn);

    var rejectBtn = document.createElement('button');
    rejectBtn.className = 'review-reject';
    rejectBtn.textContent = '\u2717';
    rejectBtn.title = 'Reject';
    rejectBtn.setAttribute('aria-label', 'Reject');
    actionsCell.appendChild(rejectBtn);

    row.appendChild(actionsCell);
    table.appendChild(row);
  }
}

function exportReviews() {
  var result = window._lastImplicitResult;
  if (!result) return;

  var exportData = {
    timestamp: new Date().toISOString(),
    totalTags: result.implicitTags.length,
    reviews: []
  };

  for (var i = 0; i < result.implicitTags.length; i++) {
    var tag = result.implicitTags[i];
    var key = tag.entity + '::' + tag.entryId;
    exportData.reviews.push({
      entity: tag.entity,
      entryId: tag.entryId,
      score: tag.score,
      status: reviewState[key] || 'pending'
    });
  }

  var blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'implicit-tag-reviews.json';
  a.click();
  URL.revokeObjectURL(url);
}

function loadReviews() {
  var input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.addEventListener('change', function(e) {
    var file = e.target.files[0];
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function(ev) {
      try {
        var data = JSON.parse(ev.target.result);
        if (data.reviews && Array.isArray(data.reviews)) {
          for (var i = 0; i < data.reviews.length; i++) {
            var r = data.reviews[i];
            if (r.entity && r.entryId && (r.status === 'confirmed' || r.status === 'rejected')) {
              reviewState[r.entity + '::' + r.entryId] = r.status;
            }
          }
          // Re-render if we have implicit results
          if (window._lastImplicitResult) {
            var sortSelect = document.getElementById('review-sort-select');
            var filterCheckbox = document.getElementById('review-filter-unreviewed');
            renderReviewRows(window._lastImplicitResult.implicitTags, sortSelect.value, filterCheckbox.checked);
          }
        }
      } catch (err) {
        console.error('Failed to load reviews:', err);
      }
    };
    reader.readAsText(file);
  });
  input.click();
}

// ── Go ──────────────────────────────────────────────────────────────────────
init();
</script>
</body>
</html>
